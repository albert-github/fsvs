/* This file is generated, do not edit!
 * Last done on Mon Nov  7 09:41:43 2022
 * */


const char hlp_add[]="   fsvs add [-u URLNAME] PATH [PATH...]\n"
  "\n"
  "   With this command you can explicitly define entries to be versioned,\n"
  "   even if they have a matching ignore pattern. They will be sent to the\n"
  "   repository on the next commit, just like other new entries, and will\n"
  "   therefore be reported as New .\n"
  "\n"
  "   The -u option can be used if you're have more than one URL defined for\n"
  "   this working copy and want to have the entries pinned to the this URL.\n"
  "\n";

const char hlp_unvers[]="   fsvs unversion PATH [PATH...]\n"
  "\n"
  "   This command flags the given paths locally as removed. On the next\n"
  "   commit they will be deleted in the repository, and the local\n"
  "   information of them will be removed, but not the entries themselves. So\n"
  "   they will show up as New again, and you get another chance at ignoring\n"
  "   them.\n"
  "\n";

const char hlp_build[]="   This is used mainly for debugging. It traverses the filesystem and\n"
  "   builds a new entries file. In production it should not be used; as\n"
  "   neither URLs nor the revision of the entries is known, information is\n"
  "   lost by calling this function!\n"
  "\n"
  "   Look at sync-repos.\n"
  "\n";

const char hlp_delay[]="   This command delays execution until time has passed at least to the\n"
  "   next second after writing the data files used by FSVS (dir and urls).\n"
  "\n"
  "   This command is for use in scripts; where previously the delay option\n"
  "   was used, this can be substituted by the given command followed by the\n"
  "   delay command.\n"
  "\n"
  "   The advantage against the delay option is that read-only commands can\n"
  "   be used in the meantime.\n"
  "\n"
  "   An example:\n"
  "   fsvs commit /etc/X11 -m \"Backup of X11\"\n"
  "   ... read-only commands, like \"status\"\n"
  "   fsvs delay /etc/X11\n"
  "   ... read-write commands, like \"commit\"\n"
  "\n"
  "   The optional path can point to any path in the WC.\n"
  "\n"
  "   In the testing framework it is used to save a bit of time; in normal\n"
  "   operation, where FSVS commands are not so tightly packed, it is\n"
  "   normally preferable to use the delay option.\n"
  "\n";

const char hlp_cat[]="   fsvs cat [-r rev] path\n"
  "\n"
  "   Fetches a file repository, and outputs it to STDOUT. If no revision is\n"
  "   specified, it defaults to BASE, ie. the current local revision number\n"
  "   of the entry.\n"
  "\n";

const char hlp_checko[]="   fsvs checkout [path] URL [URLs...]\n"
  "\n"
  "   Sets one or more URLs for the current working directory (or the\n"
  "   directory path), and does an checkout of these URLs.\n"
  "\n"
  "   Example:\n"
  "   fsvs checkout . http://svn/repos/installation/machine-1/trunk\n"
  "\n"
  "   The distinction whether a directory is given or not is done based on\n"
  "   the\n"
  "   result of URL-parsing – if it looks like an URL, it is used as an URL.\n"
  "   Please mind that at most a single path is allowed; as soon as two\n"
  "   non-URLs are found an error message is printed.\n"
  "\n"
  "   If no directory is given, \".\" is used; this differs from the usual\n"
  "   subversion usage, but might be better suited for usage as a recovery\n"
  "   tool (where versioning / is common). Opinions welcome.\n"
  "\n"
  "   The given path must exist, and should be empty – FSVS will abort on\n"
  "   conflicts, ie. if files that should be created already exist.\n"
  "   If there's a need to create that directory, please say so; patches for\n"
  "   some parameter like -p are welcome.\n"
  "\n"
  "   For a format definition of the URLs please see the chapter Format of\n"
  "   URLs and the urls and update commands.\n"
  "\n"
  "   Furthermore you might be interested in Using an alternate root\n"
  "   directory and Recovery for a non-booting system.\n"
  "\n";

const char hlp_commit[]="   fsvs commit [-m \"message\"|-F filename] [-v] [-C [-C]] [PATH [PATH ...]]\n"
  "   filename\n"
  "   static char * filename\n"
  "   Definition: update.c:90\n"
  "\n"
  "   Commits (parts of) the current state of the working copy into the\n"
  "   repository.\n"
  "\n";

const char hlp_cp[]="   fsvs cp [-r rev] SRC DEST\n"
  "   fsvs cp dump\n"
  "   fsvs cp load\n"
  "\n"
  "   The copy command marks DEST as a copy of SRC at revision rev, so that\n"
  "   on the next commit of DEST the corresponding source path is sent as\n"
  "   copy source.\n"
  "\n"
  "   The default value for rev is BASE, ie. the revision the SRC (locally)\n"
  "   is at.\n"
  "\n"
  "   Please note that this command works always on a directory structure -\n"
  "   if you say to copy a directory, the whole structure is marked as copy.\n"
  "   That means that if some entries below the copy are missing, they are\n"
  "   reported as removed from the copy on the next commit.\n"
  "   (Of course it is possible to mark files as copied, too; non-recursive\n"
  "   copies are not possible, but can be emulated by having parts of the\n"
  "   destination tree removed.)\n"
  "\n"
  "   Note\n"
  "          TODO: There will be differences in the exact usage - copy will\n"
  "          try to run the cp command, whereas copied will just remember the\n"
  "          relation.\n"
  "\n"
  "   If this command are used without parameters, the currently defined\n"
  "   relations are printed; please keep in mind that the key is the\n"
  "   destination name, ie. the 2nd line of each pair!\n"
  "\n"
  "   The input format for load is newline-separated - first a SRC line,\n"
  "   followed by a DEST line, then an line with just a dot ( \".\") as\n"
  "   delimiter. If you've got filenames with newlines or other special\n"
  "   characters, you have to give the paths as arguments.\n"
  "\n"
  "   Internally the paths are stored relative to the working copy base\n"
  "   directory, and they're printed that way, too.\n"
  "\n"
  "   Later definitions are appended to the internal database; to undo\n"
  "   mistakes, use the uncopy action.\n"
  "\n"
  "   Note\n"
  "          Important: User-defined properties like fsvs:commit-pipe are not\n"
  "          copied to the destinations, because of space/time issues\n"
  "          (traversing through entire subtrees, copying a lot of\n"
  "          property-files) and because it's not sure that this is really\n"
  "          wanted. TODO: option for copying properties?\n"
  "\n"
  "   Todo:\n"
  "          -0 like for xargs?\n"
  "\n"
  "   Todo:\n"
  "          Are different revision numbers for load necessary? Should dump\n"
  "          print the source revision number?\n"
  "\n"
  "   Todo:\n"
  "          Copying from URLs means update from there\n"
  "\n"
  "   Note\n"
  "          As subversion currently treats a rename as copy+delete, the mv\n"
  "          command is an alias to cp.\n"
  "\n"
  "   If you have a need to give the filenames dump or load as first\n"
  "   parameter for copyfrom relations, give some path, too, as in \"./dump\".\n"
  "\n"
  "   Note\n"
  "          The source is internally stored as URL with revision number, so\n"
  "          that operations like these\n"
  "\n"
  "          $ fsvs cp a b\n"
  "\n"
  "          $ rm a/1\n"
  "\n"
  "          $ fsvs ci a\n"
  "\n"
  "          $ fsvs ci b\n"
  "          work - FSVS sends the old (too recent!) revision number as\n"
  "          source, and so the local filelist stays consistent with the\n"
  "          repository.\n"
  "          But it is not implemented (yet) to give an URL as copyfrom\n"
  "          source directly - we'd have to fetch a list of entries (and\n"
  "          possibly the data!) from the repository.\n"
  "\n"
  "   Todo:\n"
  "          Filter for dump (patterns?).\n"
  "\n";

const char hlp_copyfr[]="   fsvs copyfrom-detect [paths...]\n"
  "\n"
  "   This command tells FSVS to look through the new entries, and see\n"
  "   whether it can find some that seem to be copied from others already\n"
  "   known.\n"
  "   It will output a list with source and destination path and why it could\n"
  "   match.\n"
  "\n"
  "   This is just for information purposes and doesn't change any FSVS\n"
  "   state, (TODO: unless some option/parameter is set).\n"
  "\n"
  "   The list format is on purpose incompatible with the load syntax, as the\n"
  "   best match normally has to be taken manually.\n"
  "\n"
  "   Todo:\n"
  "          some parameter that just prints the \"best\" match, and outputs\n"
  "          the correct format.\n"
  "\n"
  "   If verbose is used, an additional value giving the percentage of\n"
  "   matching blocks, and the count of possibly copied entries is printed.\n"
  "\n"
  "   Example:\n"
  "   $ fsvs copyfrom-list -v\n"
  "   newfile1\n"
  "   md5:oldfileA\n"
  "   newfile2\n"
  "   md5:oldfileB\n"
  "   md5:oldfileC\n"
  "   md5:oldfileD\n"
  "   newfile3\n"
  "   inode:oldfileI\n"
  "   manber=82.6:oldfileF\n"
  "   manber=74.2:oldfileG\n"
  "   manber=53.3:oldfileH\n"
  "   ...\n"
  "   3 copyfrom relations found.\n"
  "\n"
  "   The abbreviations are:\n"
  "   md5\n"
  "\n"
  "   The MD5 of the new file is identical to that of one or more already\n"
  "   committed files; there is no percentage.\n"
  "\n"
  "   inode\n"
  "\n"
  "   The device/inode number is identical to the given known entry; this\n"
  "   could mean that the old entry has been renamed or hardlinked. Note: Not\n"
  "   all filesystems have persistent inode numbers (eg. NFS) - so depending\n"
  "   on your filesystems this might not be a good indicator!\n"
  "\n"
  "   name\n"
  "\n"
  "   The entry has the same name as another entry.\n"
  "\n"
  "   manber\n"
  "\n"
  "   Analysing files of similar size shows some percentage of\n"
  "   (variable-sized) common blocks (ignoring the order of the blocks).\n"
  "\n"
  "   dirlist\n"
  "\n"
  "   The new directory has similar files to the old directory.\n"
  "   The percentage is (number_of_common_entries)/(files_in_dir1 +\n"
  "   files_in_dir2 - number_of_common_entries).\n"
  "\n"
  "   Note\n"
  "          manber matching is not implemented yet.\n"
  "          If too many possible matches for an entry are found, not all are\n"
  "          printed; only an indicator ... is shown at the end.\n"
  "\n";

const char hlp_uncp[]="   fsvs uncopy DEST [DEST ...]\n"
  "\n"
  "   The uncopy command removes a copyfrom mark from the destination entry.\n"
  "   This will make the entry unknown again, and reported as New on the next\n"
  "   invocations.\n"
  "\n"
  "   Only the base of a copy can be un-copied; if a directory structure was\n"
  "   copied, and the given entry is just implicitly copied, this command\n"
  "   will return an error.\n"
  "\n"
  "   This is not folded in revert, because it's not clear whether revert on\n"
  "   copied, changed entries should restore the original copyfrom data or\n"
  "   remove the copy attribute; by using another command this is no longer\n"
  "   ambiguous.\n"
  "\n"
  "   Example:\n"
  "   $ fsvs copy SourceFile DestFile\n"
  "   # Whoops, was wrong!\n"
  "   $ fsvs uncopy DestFile\n"
  "\n";

const char hlp_diff[]="   fsvs diff [-v] [-r rev[:rev2]] [-R] PATH [PATH...]\n"
  "\n"
  "   This command gives you diffs between local and repository files.\n"
  "\n"
  "   With -v the meta-data is additionally printed, and changes shown.\n"
  "\n"
  "   If you don't give the revision arguments, you get a diff of the base\n"
  "   revision in the repository (the last commit) against your current local\n"
  "   file. With one revision, you diff this repository version against your\n"
  "   local file. With both revisions given, the difference between these\n"
  "   repository versions is calculated.\n"
  "\n"
  "   You'll need the diff program, as the files are simply passed as\n"
  "   parameters to it.\n"
  "\n"
  "   The default is to do non-recursive diffs; so fsvs diff . will output\n"
  "   the changes in all files in the current directory and below.\n"
  "\n"
  "   The output for special files is the diff of the internal subversion\n"
  "   storage, which includes the type of the special file, but no newline at\n"
  "   the end of the line (which diff complains about).\n"
  "\n"
  "   For entries marked as copy the diff against the (clean) source entry is\n"
  "   printed.\n"
  "\n"
  "   Please see also Options relating to the \"diff\" action and Using\n"
  "   colordiff.\n"
  "\n"
  "   Todo:\n"
  "          Two revisions diff is buggy in that it (currently) always\n"
  "          fetches the full trees from the repository; this is not only a\n"
  "          performance degradation, but you'll see more changed entries\n"
  "          than you want (like changes A to B to A). This will be fixed.\n"
  "\n";

const char hlp_export[]="   fsvs export REPOS_URL [-r rev]\n"
  "\n"
  "   If you want to export a directory from your repository without storing\n"
  "   any FSVS-related data you can use this command.\n"
  "\n"
  "   This restores all meta-data - owner, group, access mask and\n"
  "   modification time; its primary use is for data recovery.\n"
  "\n"
  "   The data gets written (in the correct directory structure) below the\n"
  "   current working directory; if entries already exist, the export will\n"
  "   stop, so this should be an empty directory.\n"
  "\n";

const char hlp_help[]="   help [command]\n"
  "\n"
  "   This command shows general or specific help (for the given command). A\n"
  "   similar function is available by using -h or -? after a command.\n"
  "\n";

const char hlp_groups[]="   fsvs groups dump|load\n"
  "   fsvs groups [prepend|append|at=n] group-definition [group-def ...]\n"
  "   fsvs ignore [prepend|append|at=n] pattern [pattern ...]\n"
  "   fsvs groups test [-v|-q] [pattern ...]\n"
  "\n"
  "   This command adds patterns to the end of the pattern list, or, with\n"
  "   prepend, puts them at the beginning of the list. With at=x the patterns\n"
  "   are inserted at the position x , counting from 0.\n"
  "\n"
  "   The difference between groups and ignore is that groups requires a\n"
  "   group name, whereas the latter just assumes the default group ignore.\n"
  "\n"
  "   For the specification please see the related documentation .\n"
  "\n"
  "   fsvs dump prints the patterns to STDOUT . If there are special\n"
  "   characters like CR or LF embedded in the pattern without encoding (like\n"
  "   \\r or \\n), the output will be garbled.\n"
  "\n"
  "   The patterns may include * and ? as wildcards in one directory level,\n"
  "   or ** for arbitrary strings.\n"
  "\n"
  "   These patterns are only matched against new (not yet known) files;\n"
  "   entries that are already versioned are not invalidated.\n"
  "   If the given path matches a new directory, entries below aren't found,\n"
  "   either; but if this directory or entries below are already versioned,\n"
  "   the pattern doesn't work, as the match is restricted to the directory.\n"
  "\n"
  "   So:\n"
  "   fsvs ignore ./tmp\n"
  "\n"
  "   ignores the directory tmp; but if it has already been committed,\n"
  "   existing entries would have to be unmarked with fsvs unversion.\n"
  "   Normally it's better to use\n"
  "   fsvs ignore ./tmp/**\n"
  "\n"
  "   as that takes the directory itself (which might be needed after restore\n"
  "   as a mount point anyway), but ignore all entries below.\n"
  "   Currently this has the drawback that mtime changes will be reported and\n"
  "   committed; this is not the case if the whole directory is ignored.\n"
  "\n"
  "   Examples:\n"
  "   fsvs group group:unreadable,mode:4:0\n"
  "   fsvs group 'group:secrets,/etc/*shadow'\n"
  "   fsvs ignore /proc\n"
  "   fsvs ignore /dev/pts\n"
  "   fsvs ignore './var/log/*-*'\n"
  "   fsvs ignore './**~'\n"
  "   fsvs ignore './**/*.bak'\n"
  "   fsvs ignore prepend 'take,./**.txt'\n"
  "   fsvs ignore append 'take,./**.svg'\n"
  "   fsvs ignore at=1 './**.tmp'\n"
  "   fsvs group dump\n"
  "   fsvs group dump -v\n"
  "   echo \"./**.doc\" | fsvs ignore load\n"
  "   # Replaces the whole list\n"
  "\n"
  "   Note\n"
  "          Please take care that your wildcard patterns are not expanded by\n"
  "          the shell!\n"
  "\n";

const char hlp_rign[]="   fsvs rel-ignore [prepend|append|at=n] path-spec [path-spec ...]\n"
  "   fsvs ri [prepend|append|at=n] path-spec [path-spec ...]\n"
  "\n"
  "   If you keep the same repository data at more than one working copy on\n"
  "   the same machine, it will be stored in different paths - and that makes\n"
  "   absolute ignore patterns infeasible. But relative ignore patterns are\n"
  "   anchored at the beginning of the WC root - which is a bit tiring to\n"
  "   type if you're deep in your WC hierarchy and want to ignore some files.\n"
  "\n"
  "   To make that easier you can use the rel-ignore (abbreviated as ri)\n"
  "   command; this converts all given path-specifications (which may include\n"
  "   wildcards as per the shell pattern specification above) to WC-relative\n"
  "   values before storing them.\n"
  "\n"
  "   Example for /etc as working copy root:\n"
  "   fsvs rel-ignore '/etc/X11/xorg.conf.*'\n"
  "   cd /etc/X11\n"
  "   fsvs rel-ignore 'xorg.conf.*'\n"
  "\n"
  "   Both commands would store the pattern \"./X11/xorg.conf.*\".\n"
  "\n"
  "   Note\n"
  "          This works only for shell patterns.\n"
  "\n"
  "   For more details about ignoring files please see the ignore command and\n"
  "   Specification of groups and patterns.\n"
  "\n";

const char hlp_info[]="   fsvs info [-R [-R]] [PATH...]\n"
  "\n"
  "   Use this command to show information regarding one or more entries in\n"
  "   your working copy.\n"
  "   You can use -v to obtain slightly more information.\n"
  "\n"
  "   This may sometimes be helpful for locating bugs, or to obtain the URL\n"
  "   and revision a working copy is currently at.\n"
  "\n"
  "   Example:\n"
  "   $ fsvs info\n"
  "   URL: file:\n"
  "   .... 200 .\n"
  "   Type: directory\n"
  "   Status: 0x0\n"
  "   Flags: 0x100000\n"
  "   Dev: 0\n"
  "   Inode: 24521\n"
  "   Mode: 040755\n"
  "   UID/GID: 1000/1000\n"
  "   MTime: Thu Aug 17 16:34:24 2006\n"
  "   CTime: Thu Aug 17 16:34:24 2006\n"
  "   Revision: 4\n"
  "   Size: 200\n"
  "\n"
  "   The default is to print information about the given entry only. With a\n"
  "   single -R you'll get this data about all entries of a given directory;\n"
  "   with another -R you'll get the whole (sub-)tree.\n"
  "\n";

const char hlp_log[]="   fsvs log [-v] [-r rev1[:rev2]] [-u name] [path]\n"
  "\n"
  "   This command views the revision log information associated with the\n"
  "   given path at its topmost URL, or, if none is given, the highest\n"
  "   priority URL.\n"
  "\n"
  "   The optional rev1 and rev2 can be used to restrict the revisions that\n"
  "   are shown; if no values are given, the logs are given starting from\n"
  "   HEAD downwards, and then a limit on the number of revisions is applied\n"
  "   (but see the limit option).\n"
  "\n"
  "   If you use the -v -option, you get the files changed in each revision\n"
  "   printed, too.\n"
  "\n"
  "   There is an option controlling the output format; see the log_output\n"
  "   option.\n"
  "\n"
  "   Optionally the name of an URL can be given after -u; then the log of\n"
  "   this URL, instead of the topmost one, is shown.\n"
  "\n"
  "   TODOs:\n"
  "     * --stop-on-copy\n"
  "     * Show revision for all URLs associated with a working copy? In which\n"
  "       order?\n"
  "\n";

const char hlp_prop_g[]="   fsvs prop-get PROPERTY-NAME PATH...\n"
  "\n"
  "   Prints the data of the given property to STDOUT.\n"
  "\n"
  "   Note\n"
  "          Be careful! This command will dump the property as it is, ie.\n"
  "          with any special characters! If there are escape sequences or\n"
  "          binary data in the property, your terminal might get messed up!\n"
  "          If you want a safe way to look at the properties, use prop-list\n"
  "          with the -v parameter.\n"
  "\n";

const char hlp_prop_s[]="   fsvs prop-set [-u URLNAME] PROPERTY-NAME VALUE PATH...\n"
  "\n"
  "   This command sets an arbitrary property value for the given path(s).\n"
  "\n"
  "   Note\n"
  "          Some property prefixes are reserved; currently everything\n"
  "          starting with svn: throws a (fatal) warning, and fsvs: is\n"
  "          already used, too. See Special property names.\n"
  "\n"
  "   If you're using a multi-URL setup, and the entry you'd like to work on\n"
  "   should be pinned to a specific URL, you can use the -u parameter; this\n"
  "   is like the add command, see there for more details.\n"
  "\n";

const char hlp_prop_d[]="   fsvs prop-del PROPERTY-NAME PATH...\n"
  "\n"
  "   This command removes a property for the given path(s).\n"
  "\n"
  "   See also prop-set.\n"
  "\n";

const char hlp_prop_l[]="   fsvs prop-list [-v] PATH...\n"
  "\n"
  "   Lists the names of all properties for the given entry.\n"
  "   With -v, the value is printed as well; special characters will be\n"
  "   translated, as arbitrary binary sequences could interfere with your\n"
  "   terminal settings.\n"
  "\n"
  "   If you need raw output, post a patch for --raw, or write a loop with\n"
  "   prop-get.\n"
  "\n";

const char hlp_remote[]="   fsvs remote-status PATH [-r rev]\n"
  "\n"
  "   This command looks into the repository and tells you which files would\n"
  "   get changed on an update - it's a dry-run for update .\n"
  "\n"
  "   Per default it compares to HEAD, but you can choose another revision\n"
  "   with the -r parameter.\n"
  "\n"
  "   Please see the update documentation for details regarding multi-URL\n"
  "   usage.\n"
  "\n";

const char hlp_resolv[]="   fsvs resolve PATH [PATH...]\n"
  "\n"
  "   When FSVS tries to update local files which have been changed, a\n"
  "   conflict might occur. (For various ways of handling these please see\n"
  "   the conflict option.)\n"
  "\n"
  "   This command lets you mark such conflicts as resolved.\n"
  "\n";

const char hlp_revert[]="   fsvs revert [-rRev] [-R] PATH [PATH...]\n"
  "\n"
  "   This command undoes local modifications:\n"
  "     * An entry that is marked to be unversioned gets this flag removed.\n"
  "     * For a already versioned entry (existing in the repository) the\n"
  "       local entry is replaced with its repository version, and its status\n"
  "       and flags are cleared.\n"
  "     * An entry that is a modified copy destination gets reverted to the\n"
  "       copy source data.\n"
  "     * Manually added entries are changed back to \"N\"ew.\n"
  "\n"
  "   Please note that implicitly copied entries, ie. entries that are marked\n"
  "   as copied because some parent directory is the base of a copy, can not\n"
  "   be un-copied; they can only be reverted to their original (copied-from)\n"
  "   data, or removed.\n"
  "\n"
  "   If you want to undo a copy operation, please see the uncopy command.\n"
  "\n"
  "   See also HOWTO: Understand the entries' statii.\n"
  "\n"
  "   If a directory is given on the command line all versioned entries in\n"
  "   this directory are reverted to the old state; this behaviour can be\n"
  "   modified with -R/-N, or see below.\n"
  "\n"
  "   The reverted entries are printed, along with the status they had before\n"
  "   the revert (because the new status is per definition unchanged).\n"
  "\n"
  "   If a revision is given, the entries' data is taken from this revision;\n"
  "   furthermore, the new status of that entry is shown.\n"
  "\n"
  "   Note\n"
  "          Please note that mixed revision working copies are not (yet)\n"
  "          possible; the BASE revision is not changed, and a simple revert\n"
  "          without a revision arguments gives you that.\n"
  "          By giving a revision parameter you can just choose to get the\n"
  "          text from a different revision.\n"
  "\n";

const char hlp_status[]="   fsvs status [-C [-C]] [-v] [-f filter] [PATHs...]\n"
  "\n"
  "   This command shows the entries that have been changed locally since the\n"
  "   last commit.\n"
  "\n"
  "   The most important output formats are:\n"
  "     * A status columns of four (or, with -v , six) characters. There are\n"
  "       either flags or a \".\" printed, so that it's easily parsed by\n"
  "       scripts – the number of columns is only changed by -q, -v –\n"
  "       verbose/quiet.\n"
  "     * The size of the entry, in bytes, or \"dir\" for a directory, or \"dev\"\n"
  "       for a device.\n"
  "     * The path and name of the entry, formatted by the path option.\n"
  "\n"
  "   Normally only changed entries are printed; with -v all are printed, but\n"
  "   see the filter option for more details.\n"
  "\n"
  "   The status column can show the following flags:\n"
  "     * 'D' and 'N' are used for deleted and new entries.\n"
  "     * 'd' and 'n' are used for entries which are to be unversioned or\n"
  "       added on the next commit; the characters were chosen as little\n"
  "       delete (only in the repository, not removed locally) and little new\n"
  "       (although ignored). See add and unversion.\n"
  "       If such an entry does not exist, it is marked with an \"!\" in the\n"
  "       last column – because it has been manually marked, and so the\n"
  "       removal is unexpected.\n"
  "     * A changed type (character device to symlink, file to directory\n"
  "       etc.) is given as 'R' (replaced), ie. as removed and newly added.\n"
  "     * If the entry has been modified, the change is shown as 'C'.\n"
  "       If the modification or status change timestamps (mtime, ctime) are\n"
  "       changed, but the size is still the same, the entry is marked as\n"
  "       possibly changed (a question mark '?' in the last column) - but see\n"
  "       change detection for details.\n"
  "     * A 'x' signifies a conflict.\n"
  "     * The meta-data flag 'm' shows meta-data changes like properties,\n"
  "       modification timestamp and/or the rights (owner, group, mode);\n"
  "       depending on the -v/-q command line parameters, it may be split\n"
  "       into 'P' (properties), 't' (time) and 'p' (permissions).\n"
  "       If 'P' is shown for the non-verbose case, it means only property\n"
  "       changes, ie. the entries filesystem meta-data is unchanged.\n"
  "     * A '+' is printed for files with a copy-from history; to see the URL\n"
  "       of the copyfrom source, see the verbose option.\n"
  "\n"
  "   Here's a table with the characters and their positions:\n"
  "*   Without -v    With -v\n"
  "*     ....         ......\n"
  "*     NmC?         NtpPC?\n"
  "*     DPx!         D   x!\n"
  "*     R  +         R    +\n"
  "*     d            d\n"
  "*     n            n\n"
  "*\n"
  "\n"
  "   Furthermore please take a look at the stat_color option, and for more\n"
  "   information about displayed data the verbose option.\n"
  "\n";

const char hlp_sync_r[]="   fsvs sync-repos [-r rev] [working copy base]\n"
  "\n"
  "   This command loads the file list afresh from the repository.\n"
  "   A following commit will send all differences and make the repository\n"
  "   data identical to the local.\n"
  "\n"
  "   This is normally not needed; the only use cases are\n"
  "     * debugging and\n"
  "     * recovering from data loss in the $FSVS_WAA area.\n"
  "\n"
  "   It might be of use if you want to backup two similar machines. Then you\n"
  "   could commit one machine into a subdirectory of your repository, make a\n"
  "   copy of that directory for another machine, and sync this other\n"
  "   directory on the other machine.\n"
  "\n"
  "   A commit then will transfer only changed files; so if the two machines\n"
  "   share 2GB of binaries ( /usr , /bin , /lib , ...) then these 2GB are\n"
  "   still shared in the repository, although over time they will deviate\n"
  "   (as both committing machines know nothing of the other path with\n"
  "   identical files).\n"
  "\n"
  "   This kind of backup could be substituted by two or more levels of\n"
  "   repository paths, which get overlaid in a defined priority. So the base\n"
  "   directory, which all machines derive from, will be committed from one\n"
  "   machine, and it's no longer necessary for all machines to send\n"
  "   identical files into the repository.\n"
  "\n"
  "   The revision argument should only ever be used for debugging; if you\n"
  "   fetch a filelist for a revision, and then commit against later\n"
  "   revisions, problems are bound to occur.\n"
  "\n"
  "   Note\n"
  "          There's issue 2286 in subversion which describes sharing\n"
  "          identical files in the repository in unrelated paths. By using\n"
  "          this relaxes the storage needs; but the network transfers would\n"
  "          still be much larger than with the overlaid paths.\n"
  "\n";

const char hlp_update[]="   fsvs update [-r rev] [working copy base]\n"
  "   fsvs update [-u url@rev ...] [working copy base]\n"
  "\n"
  "   This command does an update on the current working copy; per default\n"
  "   for all defined URLs, but you can restrict that via -u.\n"
  "\n"
  "   It first reads all filelist changes from the repositories, overlays\n"
  "   them (so that only the highest-priority entries are used), and then\n"
  "   fetches all necessary changes.\n"
  "\n";

const char hlp_urls[]="   fsvs urls URL [URLs...]\n"
  "   fsvs urls dump\n"
  "   fsvs urls load\n"
  "\n"
  "   Initializes a working copy administrative area and connects the current\n"
  "   working directory to REPOS_URL. All commits and updates will be done to\n"
  "   this directory and against the given URL.\n"
  "\n"
  "   Example:\n"
  "   fsvs urls http://svn/repos/installation/machine-1/trunk\n"
  "\n"
  "   For a format definition of the URLs please see the chapter Format of\n"
  "   URLs.\n"
  "\n"
  "   Note\n"
  "          If there are already URLs defined, and you use that command\n"
  "          later again, please note that as of 1.0.18 the older URLs are\n"
  "          not overwritten as before, but that the new URLs are appended to\n"
  "          the given list! If you want to start afresh, use something like\n"
  "\n"
  "          true | fsvs urls load\n"
  "\n";



// vi: filetype=c
