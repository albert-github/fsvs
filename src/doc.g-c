/* This file is generated, do not edit!
 * Last done on Sat Jan 12 16:13:18 2008
 * */


const char hlp_add[]=" fsvs add PATH [PATH...]\n"
  "\n"
  "   With this command you can explicitly define entries to be versioned,\n"
  "   even if they have a matching ignore pattern. They will be sent to the\n"
  "   repository on the next commit, just like other new entries, and will\n"
  "   therefore be reported as New .\n"
  "\n"
  "  Example\n"
  "\n"
  "   Say, you're versioning your home directory, and gave an ignore pattern\n"
  "   of ./.* to ignore all .* entries in your home-directory. Now you want\n"
  "   .bashrc, .ssh/config, and your complete .kde3-tree saved, just like\n"
  "   other data.\n"
  "\n"
  "   So you tell fsvs to not ignore these entries:\n"
  "\n"
  "    fsvs add .bashrc .ssh/config .kde3\n"
  "\n"
  "   Now the entries below .kde3 would match your earlier ./.* pattern (as a\n"
  "   match at the beginning is sufficient), so you have to insert a negative\n"
  "   ignore pattern (a take pattern):\n"
  "\n"
  "    fsvs ignore --insert t./.kde3\n"
  "\n"
  "   Now a fsvs st would show your entries as New , and the next commit will\n"
  "   send them to the repository.\n"
  "\n"
  "   Note:\n"
  "          This loads the wc data, writes the given paths with some flags\n"
  "          to it, and saves the wc data again.\n"
  "\n";

const char hlp_unvers[]=" fsvs unversion PATH [PATH...]\n"
  "\n"
  "   This command flags the given paths locally as removed. On the next\n"
  "   commit they will be deleted in the repository, and the local\n"
  "   information of them will be removed, but not the entries themselves. So\n"
  "   they will show up as New again, and you get another chance at ignoring\n"
  "   them.\n"
  "\n"
  "  Example\n"
  "\n"
  "   Say, you're versioning your home directory, and found that you no\n"
  "   longer want .bash_history and .sh_history versioned. So you do\n"
  "\n"
  "    fsvs unversion .bash_history .sh_history\n"
  "\n"
  "   and these files will be reported as d (will be deleted, but only in the\n"
  "   repository).\n"
  "\n"
  "   Then you do a\n"
  "\n"
  "    fsvs commit\n"
  "\n"
  "   Now fsvs would report these files as New , as it does no longer know\n"
  "   anything about them; but that can be cured by\n"
  "\n"
  "    fsvs ignore \"./.*sh_history\"\n"
  "\n"
  "   Now these two files won't be shown as New , either.\n"
  "\n"
  "   The example also shows why the given paths are not just entered as\n"
  "   separate ignore patterns - they are just single cases of a (probably)\n"
  "   much broader pattern.\n"
  "\n"
  "   Note:\n"
  "          If you didn't use some kind of escaping for the pattern, the\n"
  "          shell would expand it to the actual filenames, which is\n"
  "          (normally) not what you want.\n"
  "\n";

const char hlp_build[]="   This is used mainly for debugging. It traverses the filesystem and\n"
  "   build a new entries file. In production it should not be used - as the\n"
  "   revision of the entries is unknown, we can only use 0 - and loose\n"
  "   information this way!\n"
  "\n";

const char hlp_checko[]=" fsvs checkout [path] URL [URLs...]\n"
  "\n"
  "   Sets one or more URLs for the current working directory (or the\n"
  "   directory path), and does an checkout of these URLs.\n"
  "\n"
  "   Example:\n"
  "\n"
  " fsvs checkout . http://svn/repos/installation/machine-1/trunk\n"
  "\n"
  "   The distinction whether a directory is given or not is done based on\n"
  "   the result of URL-parsing -- if it looks like an URL, it is used as an\n"
  "   URL.\n"
  "   Please mind that at most a single path is allowed; as soon as two\n"
  "   non-URLs are found an error message is printed.\n"
  "\n"
  "   If no directory is given, . is used; this differs from the usual\n"
  "   subversion usage, but might be better suited for usage as a recovery\n"
  "   tool (where versioning / is common). Opinions welcome.\n"
  "\n"
  "   The given path must exist, and should be empty -- fsvs will abort on\n"
  "   conflicts, ie. if files that should be created already exist.\n"
  "   If there's a need to create that directory, please say so; patches for\n"
  "   some parameter like -p are welcome.\n"
  "\n"
  "   For a format definition of the URLs please see the chapter Format of\n"
  "   URLs and the urls and update commands.\n"
  "\n"
  "   Furthermore you might be interested in Using an alternate root\n"
  "   directory and Recovery for a non-booting system.\n"
  "\n";

const char hlp_commit[]=" fsvs commit [-m \"message\"|-F filename] [-v] [-C [-C]] [PATH [PATH ...]]\n"
  "\n"
  "   Commits the current state into the repository. It is possible to commit\n"
  "   only parts of a working copy into the repository.\n"
  "\n"
  "   Your working copy is /etc , and you've set it up and committed already.\n"
  "   Now you've changed /etc/hosts , and /etc/inittab . Since these are\n"
  "   non-related changes, you'd like them to be in separate commits.\n"
  "\n"
  "   So you simply run these commands:\n"
  "\n"
  " fsvs commit -m \"Added some host\" /etc/hosts\n"
  " fsvs commit -m \"Tweaked default runlevel\" /etc/inittab\n"
  "\n"
  "   If you're currently in /etc , you can even drop the /etc/ in front, and\n"
  "   just use the filenames.\n"
  "\n"
  "   This extended path handling on the commandline is not yet available for\n"
  "   every command. Most of them still expect you to be in the working copy\n"
  "   root.\n"
  "\n"
  "   Please see status for explanations on -v and -C . For advanced backup\n"
  "   usage see also FSVS_PROP_COMMIT_PIPE.\n"
  "\n";

const char hlp_cp[]=" fsvs cp SRC DEST\n"
  " fsvs cp dump\n"
  " fsvs cp load\n"
  "\n"
  "   This command marks DEST as a copy of SRC, so that on the next commit of\n"
  "   DEST the corresponding source path is sent as copy source.\n"
  "\n"
  "   Please note that this command works always on a directory structure -\n"
  "   if you say to copy a directory, the whole structure is marked as copy.\n"
  "   That means that if some entries below the copy are missing, they are\n"
  "   reported as removed from the copy on the next commit.\n"
  "   (Of course it is possible to mark files as copied, too; non-recursive\n"
  "   copies are not possible.)\n"
  "\n"
  "   Note:\n"
  "          Or TODO: There will be differences in the exact usage - copy\n"
  "          will try to run the cp command, whereas copied will just\n"
  "          remember the relation.\n"
  "\n"
  "   If this command are used without parameters, the currently defined\n"
  "   relations are printed; please keep in mind that the key is the\n"
  "   destination name, ie. the 2nd line of each pair!\n"
  "\n"
  "   The input format for load is newline-separated - first a SRC line,\n"
  "   followed by a DEST line, then an line with just a dot (\".\") as\n"
  "   delimiter. If you've got filenames with newlines or other special\n"
  "   characters, you have to give the paths as arguments.\n"
  "\n"
  "   Internally the paths are stored relative to the working copy base\n"
  "   directory, and they're printed that way, too.\n"
  "\n"
  "   Later definitions are appended to the internal database; to undo\n"
  "   mistakes, use the revert action.\n"
  "\n"
  "   Note:\n"
  "          Important: User-defined properties like fsvs:commit-pipe are not\n"
  "          copied to the destinations, because of space/time issues\n"
  "          (traversing through entire subtrees, copying a lot of\n"
  "          property-files) and because it's not sure that this is really\n"
  "          wanted. TODO: option for copying properties?\n"
  "\n"
  "   Todo:\n"
  "          -0 like for xargs?\n"
  "\n"
  "   Note:\n"
  "          As subversion currently treats a rename as copy+delete, the mv\n"
  "          command is an alias to cp.\n"
  "\n"
  "   If you have a need to give the filenames dump or load as first\n"
  "   parameter for copyfrom relations, give some path, too, as in ./dump.\n"
  "\n"
  "   Todo:\n"
  "          Filter for dump (patterns?).\n"
  "\n";

const char hlp_copyfr[]=" fsvs copyfrom-detect [paths...]\n"
  "\n"
  "   This command tells fsvs to look through the new entries, and see\n"
  "   whether it can find some that seem to be copied from others already\n"
  "   known.\n"
  "   It will output a list with source and destination path and why it could\n"
  "   match.\n"
  "\n"
  "   This is just for information purposes and doesn't change any FSVS\n"
  "   state, unless some option/parameter is set. (TODO)\n"
  "\n"
  "   The list format is on purpose incompatible with the load syntax, as the\n"
  "   best match normally has to be taken manually.\n"
  "\n"
  "   Todo:\n"
  "          some parameter that just prints the \"best\" match, and outputs\n"
  "          the correct format.\n"
  "\n"
  "   If verbose is used, an additional value giving the percentage of\n"
  "   matching blocks, and the count of possibly copied entries is printed.\n"
  "\n"
  "   Example:\n"
  "\n"
  "   $ fsvs copyfrom-list -v\n"
  "   newfile1\n"
  "     md5:oldfileA\n"
  "   newfile2\n"
  "     md5:oldfileB\n"
  "     md5:oldfileC\n"
  "     md5:oldfileD\n"
  "   newfile3\n"
  "     inode:oldfileI\n"
  "     manber=82.6:oldfileF\n"
  "     manber=74.2:oldfileG\n"
  "     manber=53.3:oldfileH\n"
  "     ...\n"
  "   3 copyfrom relations found.\n"
  "\n"
  "   The abbreviations are:\n"
  "\n"
  "  md5     The MD5 of the new file is identical to that of one or more already\n"
  "          committed files; there is no percentage.\n"
  "\n"
  "  inode   The device/inode number is identical to the given known entry;\n"
  "          this could mean that the old entry has been renamed or hardlinked.\n"
  "          Note: Not all filesystems have persistent inode numbers (eg. NFS) - so\n"
  "          depending on your filesystems this might not be a good indicator!\n"
  "\n"
  "  name    The entry has the same name as another entry.\n"
  "\n"
  "  manber  Analysing files of similar size shows some percentage of\n"
  "          (variable-sized) common blocks (ignoring the order of the blocks).\n"
  "\n"
  "  dirlist The new directory has similar files to the old directory.\n"
  "          The percentage is (number_of_common_entries)/(files_in_dir1 +\n"
  "          files_in_dir2 - number_of_common_entries)\n"
  "\n"
  "   Note:\n"
  "          Only md5, name and inode matching currently done.\n"
  "          If too many possible matches are found, not all may be printed;\n"
  "          only the indicator ... is shown at the end.\n"
  "\n";

const char hlp_diff[]=" fsvs diff [-v] [-r rev[:rev2]] [-R] PATH [PATH...]\n"
  "\n"
  "   This command gives you diffs between local and repository files.\n"
  "\n"
  "   With -v the meta-data is additionally printed, and changes shown.\n"
  "\n"
  "   If you don't give the revision arguments, you get a diff of the base\n"
  "   revision in the repository (the last commit) against your current local\n"
  "   file. With one revision, you diff this repository version against you\n"
  "   local file. With both revisions given, the difference between these\n"
  "   repository versions is calculated.\n"
  "\n"
  "   You'll need the diff program, as the files are simply passed as\n"
  "   parameters to it.\n"
  "\n"
  "   The default is to do non-recursive diffs; so fsvs diff . will output\n"
  "   the changes in all files in the current directory.\n"
  "\n"
  "   The output for non-files is not defined.\n"
  "\n"
  "   Please see also Options relating to the \"diff\" action and Using\n"
  "   colordiff.\n"
  "\n";

const char hlp_export[]=" fsvs export REPOS_URL [-r rev]\n"
  "\n"
  "   If you want to export a directory from your repository without having\n"
  "   to have an WAA-area, you can use this command. This restores all\n"
  "   meta-data - owner, group, access mask and modification time. Its\n"
  "   primary use is for data recovery.\n"
  "\n"
  "   The data gets written (in the correct directory structure) below the\n"
  "   current working directory; if entries already exist, the export will\n"
  "   stop, so this should be an empty directory.\n"
  "\n";

const char hlp_help[]=" help [command]\n"
  "\n"
  "   This command shows general or specific help (for the given command). A\n"
  "   similar function is available by using -h or -? after a command.\n"
  "\n";

const char hlp_ignore[]=" fsvs ignore [prepend|append|at=n] pattern[s]\n"
  " fsvs ignore dump|load\n"
  "\n"
  "   This command adds patterns to the end of the ignore list, or, with\n"
  "   prepend , puts them at the beginning of the list. With at=x the\n"
  "   patterns are inserted at the position x , counting from 0.\n"
  "\n"
  "   fsvs dump prints the patterns to STDOUT . If there are special\n"
  "   characters like CR or LF embedded in the pattern without encoding (like\n"
  "   \\r or \\n), the output will be garbled.\n"
  "\n"
  "   The patterns may include * and ? as wildcards in one directory level,\n"
  "   or ** for arbitrary strings.\n"
  "\n"
  "   These patterns are only matched against new files; entries that are\n"
  "   already versioned are not invalidated. If the given path matches a new\n"
  "   directory, entries below aren't found, either; but if this directory or\n"
  "   entries below are already versioned, the pattern doesn't work, as the\n"
  "   match is restricted to the directory.\n"
  "\n"
  "   So:\n"
  "\n"
  "     fsvs ignore ./tmp\n"
  "\n"
  "   ignores the directory tmp; but if it has already been committed,\n"
  "   existing entries would have to be unmarked with fsvs unversion.\n"
  "   Normally it's better to use\n"
  "\n"
  "     fsvs ignore ./tmp/**\n"
  "\n"
  "   as that takes the directory itself (which might be needed after restore\n"
  "   as a mount point), but ignore all entries below.\n"
  "\n"
  "   Other special variants are available, see the documentation Ignore\n"
  "   patterns - user part .\n"
  "\n"
  "   Examples:\n"
  "\n"
  "     fsvs ignore ./proc\n"
  "     fsvs ignore ./dev/pts\n"
  "     fsvs ignore './var/log/*-*'\n"
  "     fsvs ignore './**~'\n"
  "     fsvs ignore './**/*.bak'\n"
  "     fsvs ignore prepend 't./**.txt'\n"
  "     fsvs ignore append 't./**.svg'\n"
  "     fsvs ignore at=1 './**.tmp'\n"
  "     fsvs ignore dump\n"
  "     fsvs ignore dump -v\n"
  "     echo \"./**.doc\" | fsvs ignore load\n"
  "\n"
  "   Note:\n"
  "          Please take care that your wildcard patterns are not expanded by\n"
  "          the shell!\n"
  "\n";

const char hlp_info[]=" fsvs info [-R [-R]] [PATH...]\n"
  "\n"
  "   Use this command to show information regarding one or more entries in\n"
  "   your working copy. Currently you must be at the working copy root; but\n"
  "   that will change. You can use -v to obtain slightly more information.\n"
  "\n"
  "   This may sometimes be helpful for locating bugs, or to obtain the URL\n"
  "   and revision a working copy is currently at.\n"
  "\n"
  "   Example:\n"
  "\n"
  "     $ fsvs info\n"
  "     URL: file:\n"
  "     ....       200  .\n"
  "             Type:           directory\n"
  "             Status:         0x0\n"
  "             Flags:          0x100000\n"
  "             Dev:            0\n"
  "             Inode:          24521\n"
  "             Mode:           040755\n"
  "             UID/GID:        1000/1000\n"
  "             MTime:          Thu Aug 17 16:34:24 2006\n"
  "             CTime:          Thu Aug 17 16:34:24 2006\n"
  "             Revision:       4\n"
  "             Size:           200\n"
  "\n"
  "   The default is to print information about the given entry only. With a\n"
  "   single -R you'll get this data about all entries of a given directory;\n"
  "   with a second -R you'll get the whole (sub-)tree.\n"
  "\n";

const char hlp_log[]=" fsvs log [-v] [-r rev1[:rev2]] [path]\n"
  "\n"
  "   This command views the log information associated with the given path,\n"
  "   or, if none, the highest priority URL.\n"
  "\n"
  "   The optional rev1 and rev2 can be used to restrict the revisions that\n"
  "   are shown; if no values are given, the logs are given starting from\n"
  "   HEAD downwards.\n"
  "\n"
  "   If you use the -v-option, you get the files changed in each revision\n"
  "   printed, too.\n"
  "\n"
  "   Currently at most 100 log messages are shown.\n"
  "\n"
  "   There is an option controlling the output format; see \"fsvs log\" output\n"
  "   format.\n"
  "\n"
  "   TODOs:\n"
  "     * --stop-on-copy\n"
  "     * Show revision for all URLs associated with a working copy? In which\n"
  "       order?\n"
  "     * A URL-parameter, to specify the log URL. (Name)\n"
  "     * Limit number of revisions shown?\n"
  "\n";

const char hlp_prop_g[]=" fsvs prop-get PROPERTY-NAME PATH...\n"
  "\n"
  "   You get the data of the property printed to STDOUT.\n"
  "\n"
  "   Note:\n"
  "          Be careful! This command will dump the property as it is, ie.\n"
  "          with any special characters! If there are escape sequences or\n"
  "          binary data in the property, your terminal might get messed up!\n"
  "          If you want a safe way to look at the properties, use prop-list\n"
  "          with the -v parameter.\n"
  "\n";

const char hlp_prop_s[]=" fsvs prop-set PROPERTY-NAME VALUE PATH...\n"
  "\n"
  "   This command sets an arbitrary property value for the given path(s).\n"
  "\n"
  "   Note:\n"
  "          Some property prefixes are reserved; currently everything\n"
  "          starting with svn: throws a (fatal) warning, and fsvs: is\n"
  "          already used, too. See Special property names.\n"
  "\n";

const char hlp_prop_d[]=" fsvs prop-del PROPERTY-NAME PATH...\n"
  "\n"
  "   This command removes property value for the given path(s).\n"
  "\n"
  "   See also prop-set\n"
  "\n";

const char hlp_prop_l[]=" fsvs prop-list [-v] PATH...\n"
  "\n"
  "   Lists the names of all properties for the given entry. With -v, the\n"
  "   value is printed as well; special characters will be translated, to not\n"
  "   mess with your terminal.\n"
  "\n"
  "   If you need raw output, post a patch for --raw, or loop with prop-get.\n"
  "\n";

const char hlp_remote[]=" fsvs remote-status PATH [-r rev]\n"
  "\n"
  "   This command looks into the repository and tells you which files would\n"
  "   get changed on an update - it's a dry-run for update .\n"
  "\n"
  "   Per default it compares to HEAD, but you can choose another revision\n"
  "   with the -r parameter.\n"
  "\n";

const char hlp_revert[]=" fsvs revert [-rRev] [-R] PATH [PATH...]\n"
  "\n"
  "   This command replaces a local entry with its repository version.\n"
  "\n"
  "   If a directory is given on the command line all known entries in this\n"
  "   directory are reverted to the old state; this behaviour can be modified\n"
  "   with -N, -R -- recursion, or see below.\n"
  "\n"
  "   The reverted entries are printed, along with the status they had before\n"
  "   the revert (because the new status is unchanged).\n"
  "\n"
  "   If a revision is given, its data is taken; furthermore, the new status\n"
  "   of that entry is shown.\n"
  "   Note:\n"
  "          Please note that mixed revision working copies are not possible;\n"
  "          the BASE revision is not changed, and a simple revert without a\n"
  "          revision arguments gives you that.\n"
  "\n"
  "  Difference to update\n"
  "\n"
  "   If you find that something doesn't work as it should, you can revert\n"
  "   entries until you are satisfied, and directly commit the new state.\n"
  "\n"
  "   In contrast, if you update to an older version, you\n"
  "     * cannot choose single entries (no mixed revision working copies),\n"
  "     * and you cannot commit the old version with changes, if later\n"
  "       changes would conflict in the repository.\n"
  "\n"
  "  Currently only known (already versioned) entries\n"
  "\n"
  "   are handled. If you need a switch (like --delete in rsync(1) ) to\n"
  "   remove unknown (new, not yet versioned) entries, to get the directory\n"
  "   in the exact state it is in the repository, say so.\n"
  "\n"
  "  If a path is specified whose parent is missing, \\c\n"
  "\n"
  "   fsvs complains. We plan to provide a switch (probably -p), which would\n"
  "   create (a sparse) tree up to this entry.\n"
  "\n"
  "  Recursive behaviour\n"
  "\n"
  "   When the user specifies a non-directory entry (file, device, symlink),\n"
  "   this entry is reverted to the old state. This is the easy case.\n"
  "\n"
  "   If the user specifies a directory entry, see this table for the\n"
  "   restoration results:\n"
  "\n"
  "   command line switch                        result\n"
  "   -N                  this directory only (meta-data),\n"
  "   none                this directory, and direct children of the directory,\n"
  "   -R                  this directory, and the complete tree below.\n"
  "\n";

const char hlp_status[]=" fsvs status [-C [-C]] [-v] [PATHs...]\n"
  "\n"
  "   This command shows the entries that have changed since the last commit.\n"
  "\n"
  "   The output is formatted as follows:\n"
  "     * A status columns of four (or, with -v , five) characters. There are\n"
  "       either flags or a \".\" printed, so that it's easily parsed by\n"
  "       scripts -- the number of columns is only changed by -q, -v --\n"
  "       verbose/quiet.\n"
  "     * The size of the entry, in bytes, or \"dir\" for a directory, or \"dev\"\n"
  "       for a device.\n"
  "     * The path and name of the entry, formatted by the option Displaying\n"
  "       paths.\n"
  "\n"
  "   The status column can show the following flags:\n"
  "     * Normally only changed entries are printed; with -v all are printed.\n"
  "       The command line option -v additionally causes the 'm' -flag to be\n"
  "       split into two, see below.\n"
  "     * 'D' and 'N' are used for deleted and new entries.\n"
  "     * 'd' and 'n' are used for entries which are to be unversioned or\n"
  "       added on the next commit; the characters were chosen as little\n"
  "       delete (only in the repository, not removed locally) and little new\n"
  "       (although ignored). See add and unversion.\n"
  "       If such an entry does not exist, it is marked with an '!' --\n"
  "       because it has been manually marked, and for both types removing\n"
  "       the entry makes no sense.\n"
  "     * A changed type (character device to symlink, file to directory\n"
  "       etc.) is given as 'R' (replaced), ie. as removed and newly added.\n"
  "     * If the entry has been modified, the change is shown as 'C'.\n"
  "       If the modification or status change timestamps (mtime, ctime) are\n"
  "       changed, but the size is still the same, the entry is marked as\n"
  "       possibly changed (a question mark '?' is printed). See\n"
  "       opt_checksum.\n"
  "     * The meta-data flag 'm' shows meta-data changes like properties,\n"
  "       modification timestamp and/or the rights (owner, group, mode);\n"
  "       depending on the verbose/quiet command line parameters, it may be\n"
  "       splitted into 'P' (properties), 't' (time) and 'p' (permissions).\n"
  "       If 'P' is shown for the non-verbose case, it means only property\n"
  "       changes, ie. the entries filesystem meta-data is unchanged.\n"
  "     * A '+' is printed for files with a copy-from history; to see the URL\n"
  "       of the copyfrom source, use -v twice.\n"
  "\n"
  "   Here's a table with the characters and their positions:\n"
  "\n"
  " *   Without -v    With -v\n"
  " *     ....         ......\n"
  " *     NmC?         NtpPC?\n"
  " *     DP !         D    !\n"
  " *     R  +         R    +\n"
  " *     d            d\n"
  " *     n            n\n"
  " *\n"
  "\n"
  "   Furthermore please take a look at Status output coloring.\n"
  "\n";

const char hlp_sync_r[]=" fsvs sync-repos [-r rev] [working copy base]\n"
  "\n"
  "   This command loads the file list from the repository. A following\n"
  "   commit will send all differences and make the repository data identical\n"
  "   to the local.\n"
  "\n"
  "   This is normally not needed; the use cases are\n"
  "     * debugging and\n"
  "     * recovering from data loss in $FSVS_WAA (/var/spool/fsvs ).\n"
  "\n"
  "   It is (currently) important if you want to backup two similar machines.\n"
  "   Then you can commit one machine into a subdirectory of your repository,\n"
  "   make a copy of that directory for another machine, and sync this other\n"
  "   directory on the other machine.\n"
  "\n"
  "   A commit then will transfer only _changed_ files; so if the two\n"
  "   machines share 2GB of binaries (/usr , /bin , /lib , ...) then these\n"
  "   2GB are still shared in the repository, although over time they will\n"
  "   deviate (as both committing machines know nothing of the other path\n"
  "   with identical files).\n"
  "\n"
  "   This kind of backup could be substituted by several levels of\n"
  "   repository paths, which get \"overlayed\" in a defined priority. So the\n"
  "   base directory, which all machines derive from, will be committed from\n"
  "   one machine, and it's no longer necessary for all machines to send\n"
  "   identical files into the repository.\n"
  "\n"
  "   The revision argument should only ever be used for debugging; if you\n"
  "   fetch a filelist for a revision, and then commit against later\n"
  "   revisions, problems are bound to occur.\n"
  "\n"
  "   Note:\n"
  "          There's an issue in subversion, to collapse identical files in\n"
  "          the repository into a single storage. That would ease the simple\n"
  "          backup example, in that there's not so much storage needed over\n"
  "          time; but the network transfers would still be much more than\n"
  "          needed.\n"
  "\n";

const char hlp_update[]=" fsvs update [-r rev] [working copy base]\n"
  "\n"
  "   This command does an update on all URLs for the current working copy.\n"
  "\n"
  "   It first reads all changes in the repositories, overlays them (so that\n"
  "   only the highest-priority entries are used), and fetches all necessary\n"
  "   changes.\n"
  "\n"
  "   Currently all URLS are update to the same revision (given per -r or\n"
  "   HEAD by default) - although there'll be a way to update only some, and\n"
  "   to a specific revision.\n"
  "\n";

const char hlp_urls[]=" fsvs urls URL [URLs...]\n"
  " fsvs urls dump\n"
  " fsvs urls load\n"
  "\n"
  "   Initializes a working copy administrative area and connects the current\n"
  "   working directory to REPOS_URL. All commits and updates will be done to\n"
  "   this directory and against the given URL.\n"
  "\n"
  "   Example:\n"
  "\n"
  " fsvs urls http://svn/repos/installation/machine-1/trunk\n"
  "\n"
  "   For a format definition of the URLs please see the chapter Format of\n"
  "   URLs .\n"
  "\n"
  "   Note:\n"
  "          If there are already URLs defined, and use that command later\n"
  "          again, please note that as of 1.0.18 the older URLs are not\n"
  "          overwritten as before, but that the new URLs are appended to the\n"
  "          given list! If you want to start afresh, use something like\n"
  " echo \"\" | fsvs urls load\n"
  "\n"
  "  Loading URLs\n"
  "\n"
  "   You can load a list of URLs from STDIN; use the load subcommand for\n"
  "   that.\n"
  "\n"
  "   Example:\n"
  "\n"
  " ( echo 'N:local,prio:10,http://svn/repos/install/machine-1/trunk' ;\n"
  "     echo 'P:50,name:common,http://svn/repos/install/common/trunk' ) |\n"
  "   fsvs urls load\n"
  "\n"
  "   Empty lines are ignored.\n"
  "\n"
  "  Dumping the defined URLs\n"
  "\n"
  "   To see which URLs are in use for the current WC, you can use dump .\n"
  "\n"
  "   As an optional parameter you can give a format statement; p , n , r, t\n"
  "   and u are substituted by the priority, name, current revision, target\n"
  "   revision and URL. Note: That's not a real printf()-format; only these\n"
  "   and a few \\ sequences are recognized.\n"
  "\n"
  "   Example:\n"
  "\n"
  " fsvs urls dump \"  %u %n:%p\\\\n\"\n"
  "   http://svn/repos/installation/machine-1/trunk local:10\n"
  "   http://svn/repos/installation/common/trunk common:50\n"
  "\n"
  "   The default format is \"N:%n,P:%p,D:%t,%u\\\\n\" .\n"
  "\n";



// vi: filetype=c
