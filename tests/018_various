#!/bin/bash

set -e 
$PREPARE_CLEAN > /dev/null
$INCLUDE_FUNCS
cd $WC

# If the filename and the message overlap, the "log -v" test
# "grep"s the wrong data.
file=x-commit-msg-file-$RANDOM-$RANDOM-$RANDOM-x
# Date in a german locale gives "JÃ¤n", in the locale codeset - to verify 
# the correct en/deconding!
# We don't use the 1st - depending on the timezone settings this might give  
# us December.
msg="$STG_UTF8.$STG_LOC"

logfile=$LOGDIR/018.log

# Exercise the commit msg editor code. Try an empty file, too.
echo $RANDOM > $file
EDITOR="touch" $BINdflt ci 
echo $msg > $file
EDITOR="cp $file" $BINdflt ci -o author=NoSuchMan

svn log $REPURL -rHEAD > $logfile
if grep $msg < $logfile > /dev/null
then
	$SUCCESS "Message was taken"
else
	$ERROR "Message not fetched from editor!"
fi

if [[ "$PROTOCOL" != "file://" ]]
then
  $WARN "Author only taken for file://; doesn't work for svn+ssh."
else
	if grep NoSuchMan < $logfile > /dev/null
	then
		$SUCCESS "Author was taken"
	else
		$ERROR "Author not used on commit"
	fi
fi


$BINdflt log -rHEAD > $logfile 2>&1
if grep $msg < $logfile > /dev/null
then
	$SUCCESS "'fsvs log -rX' works."
else
	$ERROR "'fsvs log -rX' doesn't work."
fi


# For the just created file there should be only a single revision.
$BINdflt log $file > $logfile 2>&1
if grep $msg < $logfile > /dev/null
then
	$SUCCESS "'fsvs log file' works."
else
	$ERROR "'fsvs log file' doesn't work."
fi

# Test log output options
$BINdflt log -o log_output=normal $file > $logfile
if grep "^$msg" < $logfile > /dev/null
then
	$SUCCESS "Normal log output works"
else
	$ERROR "Normal log output wrong"
fi

$BINdflt log -o log_output=indent,color $file > $logfile
# I cannot make grep and egrep understand \x1b.
# Double reverse logic - if 0 lines found, return non-zero.
if grep "^  $msg" < $logfile > /dev/null &&
	perl -e 'exit (0 == grep(/\x1b\[0;0m/, <STDIN>))' < $logfile
then
	$SUCCESS "Indented, colorized log output works"
else
	$ERROR "Indented, colorized log output wrong"
fi


# Test -F for commit message, with a very long line.
# That can fail for non-UTF8-characters, if one would get cut in the 
# middle. (That's why there are so many strange things in the above line!)
for a in `seq 1 200` ; do echo -n $msg$msg ; done > $file
$BINdflt ci -F $file

if svn log $REPURL -rHEAD | grep $msg$msg > $logfile 2>&1
then
	$SUCCESS "message was taken"
else
	$ERROR "message not read from file!"
fi

# Test log -v
$BINdflt log -rHEAD:HEAD -v > $logfile 2>&1
if grep $file < $logfile > /dev/null
then
	$SUCCESS "'fsvs log -v -rX:Y' works."
else
	$ERROR "'fsvs log -v -rX:Y' doesn't work."
fi

# Test empty file
> $file
$BINdflt ci -F $file

# Test limit parameter
$BINdflt log -rHEAD:1 -o limit=1 $file > $logfile
if [[ `wc -l < $logfile` -eq 5 ]]
then
  $SUCCESS "log limit obeyed"
else
	cat $logfile
	wc -l < $logfile
  $ERROR "log limit doesn't work"
fi


# Test EPIPE handling.
# I could reproduce it with "strace -o /dev/null $BINdflt log | true", (or 
# "| head -1"), but only in 1 of 10 cases without the strace.
strace_bin=`which strace || true`
strace_cmd=${strace_bin:+$strace_bin -o /dev/null}
for command in log st
do
	ret=$(
		set -o pipefail
		$strace_cmd $BINdflt $command 2>$logfile | true
		echo $?
		set +o pipefail )
	if [[ $ret -eq 0 ]]
	then
		# No errors on STDOUT allowed.
		if [[ `wc -l < $logfile` -eq 0 ]]
		then
			$SUCCESS "EPIPE on $command handled correctly"
		else
			$ERROR "wrong number of output lines on EPIPE $command test"
		fi
	else
		$ERROR "Error code on EPIPE $command"
	fi
done


# Test whether / at the end of an URL are removed
$BINq init $REPURL/////
if $BINdflt st > $logfile
then
	$SUCCESS "slashes at end of URLs are ignored."
else
	$ERROR "slashes make fsvs fail??"
fi

if [[ `$BINq help | wc -l` -gt 10 &&
`$BINq -h | wc -l` -gt 10 &&
`$BINq -V` == "FSVS"*"version "* ]]
then
	$SUCCESS "version and help are given"
else
	$ERROR "version or help are not printed?"
fi

if [[ "$opt_DEBUG" == "1" ]]
then
	if FSVS_DEBUGLEVEL=1 $BINdflt -v -D main | grep LC_ALL > $logfile &&
		test `$BINdflt -v -d -D main | egrep "^[^ ]+ +main" | wc -l` -ge 3
	then
		$SUCCESS "Debug messages seem to work"
	else
		$ERROR "debug doesn't work?"
	fi
fi


if [[ `$BINdflt s 2>&1 ` == *"Action \"s\" is ambiguous."* &&
	`$BINdflt invalid-action-which-will-never-exist 2>&1` == \
		*"Action "*" not found."* ]]
then
	$SUCCESS "actions are checked"
else
	$ERROR "actions are not verified?"
fi


if $BINdflt st /$RANDOM/$RANDOM/$RANDOM/$RANDOM/$RANDOM > $logfile 2>&1
then
	$ERROR "non-existing directories don't fail?"
else
	$SUCCESS "error for non-existing directories"
fi


# Define an empty configuration directory, and try to do a status (without 
# a wc file).
if FSVS_CONF=$WC $BINdflt status -N -N /sbin /bin > $logfile 2>&1
then
	$ERROR "Didn't expect status output"
else
	$SUCCESS "No status output for non-committed WCs"
fi

# make a wc, and retry
( 
	export FSVS_CONF=$WC FSVS_WAA=$WC 
	cd / 
	echo file:/// | $BINq urls load 
	echo './*' | $BINq ignore load 
)
if FSVS_CONF=$WC FSVS_WAA=$WC $BINdflt status -N -N /sbin /bin > $logfile 2>&1
then
	if ! grep '^N\.\.\. \+dir \+/s\?bin$' $logfile > $logfile.2
	then
	  $ERROR "Wrong status output"
	fi

	if [[ `wc -l < $logfile` -eq 2 &&
				`wc -l < $logfile.2` -eq 2 ]]
	then
		$SUCCESS "Status output for two root entries as expected."
	else
		$ERROR "Wrong status output"
	fi
else
	$ERROR "No status output for non-committed WCs?"
fi


# Test whether an invalid/not existing $FSVS_WAA allows "help" to work
if FSVS_WAA=/tmp/not-existing-$RANDOM$RANDOM$RANDOM$RANDOM$RANDOM $BINdflt help status > $logfile 2>&1
then
	$SUCCESS 'help needs no $FSVS_WAA'
else
	$ERROR 'help tries to access $FSVS_WAA'
fi

if $BINdflt -V | grep version | grep GPL | grep Marek > /dev/null
then
  $SUCCESS "Version is printed"
else
  $ERROR "Version printing error"
fi

if $BINdflt -v -V | grep "compiled .*, with options" > /dev/null
then
  $SUCCESS "Compile options are printed"
else
  $ERROR "Verbose version printing error"
fi

if $BINdflt help | grep "Known commands:" > /dev/null
then
  $SUCCESS "Help gets printed"
else
  $ERROR "No help output?"
fi

if $BINdflt help help | grep 'Help for command "help".' > /dev/null
then
  $SUCCESS "Help for help gets printed"
else
  $ERROR "No help help output?"
fi

if $BINdflt help -h | grep 'Help for command "help".' > /dev/null
then
  $SUCCESS "Help -h gets printed"
else
  $ERROR "No help -h output?"
fi

if $BINdflt help -? | grep 'Help for command "help".' > /dev/null
then
  $SUCCESS "Help -? gets printed"
else
  $ERROR "No help -? output?"
fi



# If we have an invalid charset, ANSI_X3.4-1968 is returned (=ASCII).
# So there should never be an error, unless nl_langinfo fails.
#if ! LC_ALL=invalid LC_CTYPE=invalid $BINdflt -Wcharset-invalid=stop st 2> $logfile
#then
#  $SUCCESS "invalid locales can stop fsvs"
#else
#  $ERROR_NB "invalid locales don't give an error?" 
#	exit 1
#fi
#

