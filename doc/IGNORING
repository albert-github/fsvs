Using ignore patterns

Why should I ignore files?

   Ignore patterns are used to ignore certain directory entries, where
   versioning makes no sense to the user. If you're versioning the
   complete installation of a machine, you wouldn't care to store the
   contents of /proc (see man 5 proc), or possibly because of security
   reasons you don't want /etc/shadow , /etc/sshd/ssh_host_*key , and/or
   other password-containing files.

   Ignore patterns allow you to define which directory entries (files,
   subdirectories, devices, symlinks etc.) should be taken respectively
   ignored.

   There are some kinds of ignore patterns; they are listed below.

Shell-like patterns

   These must start with ./, just like a base-directory-relative path. ? ,
   * as well as character classes [a-z] have their usual meaning, and **
   is a wildcard for directory levels.

   You can use a backslash \ outside of character classes to match usually
   special characters literally, eg. \* within a pattern will match a
   literal asterisk character within a file or directory name. Within
   character classes all characters except ] are treated literally. If a
   literal ] should be included in a character class, it can be placed as
   the first character or also be escaped using a backslash.

   Example for / as the base-directory
     ./[oa]pt
     ./sys
     ./proc/*
     ./home/**~

   This would ignore files and directories called apt or opt in the root
   directory (and files below, in the case of a directory), the directory
   /sys and everything below, the contents of /proc (but take the
   directory itself, so that upon restore it gets created as a
   mountpoint), and all entries matching *~ in and below /home .

   Note:
          The patterns are anchored at the beginning and the end. So a
          pattern ./sys will match only a file or directory named sys. If
          you want to exclude a directories' files, but not the directory
          itself, use something like ./dir/* or ./dir/**

Absolute shell patterns

   There's another way to specify shell patterns - using absolute paths.
   The syntax is similar to normal shell patterns; but instead of the ./
   prefix the full path, starting with /, is used.

         /etc/**.dpkg-old
         /etc/**.dpkg-bak
         /**.bak
         /**~

   The advantage of using full paths is that a later dump and load in
   another working copy (eg. when moving from versioning /etc to /) does
   simply work; the patterns don't have to be modified.

   Internally this simply tries to remove the working copy base directory
   at the start of the patterns; then they are processed as usually.

   If a pattern does not match the wc base, and neither has the
   wild-wildcard prefix /**, a warning is issued; this can be handled as
   usual.

PCRE-patterns

   PCRE stands for Perl Compatible Regular Expressions; you can read about
   them with man pcre (if the manpages are installed), and/or perldoc
   perlre (if perldoc is installed)

   These patterns have the form PCRE:{pattern} (with PCRE in uppercase, to
   distinguish from modifiers).

   An example:
     PCRE:./home/.*~

   This one achieves exactly the same as ./home/**~ .

   Another example:
     PCRE:./home/[a-s]

   This would match /home/anthony , /home/guest , /home/somebody and so
   on, but would not match /home/theodore .

   Note that the pathnames start with ./ , just like above, and that the
   patterns are anchored at the beginning. To additionally anchor at the
   end you could use a $ at the end.

Ignoring all files on a device

   Another form to discern what is needed and what not is possible with
   DEVICE:[<|<=|>|>=]major[:minor].

   This takes advantage of the major and minor numbers of inodes (see man
   1 stat and man 2 stat).

   The rule is as follows:
     * Directories have their parent matched against the given string
     * All other entries have their own device matched.

   This is because the mount-point (ie. the directory, where the other
   filesystem gets attached) should be versioned (as it's needed after
   restore), but all entries (and all binding mounts) should not.

   The possible options <= or >= define a less-or-equal-than respective
   bigger-or-equal-than relationship, to ignore a set of device classes.

   Examples:
     tDEVICE:3
     ./*

   This patterns would define that all filesystems on IDE-devices (with
   major number 3) are taken , and all other files are ignored.

    DEVICE:0

   This would ignore all filesystems with major number 0 - in linux these
   are the virtual filesystems ( proc , sysfs , devpts , etc.; see
   /proc/filesystems , the lines with nodev ).

   Mind NFS and smb-mounts, check if you're using md , lvm and/or
   device-mapper !

   Note: The values are parsed with strtoul() , so you can use decimal,
   hexadecimal (with 0x prepended) and octal (with 0 prepended) notation.

Ignoring a single file, by inode

   At last, another form to ignore entries is to specify them via the
   device their on and their inode:
     INODE:major:minor:inode

   This can be used if a file can be hardlinked to many places, but only
   one copy should be stored. Then one path can be marked as to take , and
   other instances are ignored.
   Note:
          That's probably a bad example. There should be a better
          mechanism for handling hardlinks, but that needs some help from
          subversion.

Modifiers

   All of these patterns can have one or more of these modifiers *before*
   them; not all combinations make sense.

   Modifier                    Meaning
      i     Ignore case for matching
      t     A negative ignore pattern, ie. a take pattern.

     t./proc/stat
     ./proc/

   Such declaration would store only /proc/stat , and nothing else of
   /proc .
