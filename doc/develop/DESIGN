The internal design
-------------------

0) Terms used in this document


0a) entry
In subversion speak an entry is either a directory, a symlink or a file. 
In fsvs it can additionally be a block or character device. 
Sockets an pipes are currently ignored, as they're typically 
re-created by the various applications.


0b) waa
This means "working copy administrative area"; a directory, where 
local data is stored.



1) The waa storage area


1a) Format
The waa area is the local storage area for fsvs.
Here the local data is stored, ie. filelists, ignorelists, repository URLs, 
and more.

Generally a path can be of (nearly) arbitrary length, and have every 
character (saving NUL, "\0") in it.

So wherever pathnames or similar things are stored (eg. patterns), they 
are NUL-terminated.
Furthermore the data sets have a linefeed ("\n") after them, to ease 
inspection in an editor.


1aI) Filelists
The filelists remember the last committed state of entries. That includes 
the ctime, mtime, unix-mode (with flags for directory/device/symlink/file), 
MD5 sum, size in bytes, inode, tree relation, number of child nodes, 
user and group, and filename.
The path can be recreated from the tree-structure and the filenames.

The header includes fields such as header version, header length, number 
of entries, needed space for the filenames, and the length of the 
longest path - most of that for memory allocation.


1aII) Ignore lists
They consist of a header with the number of ignore entries, followed by 
the ignore patterns; NUL-terminated, LF-separated.


1aIII) URL lists
They consist of a header with the number of URLs, followed by the URLs 
themselves; NUL-terminated, LF-separated.


1aVI) MD5
To speed up comparing and committing large files, these files should hold 
some parameters for manber hashing and a list of MD5 hashes for the 
manber blocks.
This way big files don't have to be hashed in full to check whether they've 
changed.
And the manber blocks can be used for the delta algorithm.


1aV) Prop
These files should store properties, which are not understood or not used 
by fsvs. (Not implemented yet)


1aIV) New
They were originally thought to store newly added files, but it seems I 
don't need them.



1b) Location
The default location is /var/spool/fsvs, but can be specified with the 
environment variable "WAA".


1c) Requirements
The waa doesn't need that much space. The ignore and url lists are 
typically a few kB.
And as soon as the filelist is stored compressed, the needed space should 
not exceed a few MB.


2) In memory layout

In memory fsvs builds a complete tree of the needed entries (struct estat).
They are referenced with the parent pointers to the root, and the by_inode 
and by_name downwards.

The by_inode and by_name members are pointers to arrays of pointers to 
entries (:-); their values must be the same, apart from the sorting order.
While running through a directory (or the whole tree in waa__input_tree) 
we use the by_inode-order, as this is faster; when checking a directory 
for new entries, we compare by name and use by_name.


2a) Storage and allocation
Every node can have string space allocated, ie. space needed for the 
filenames in this directory (and possibly sub-directories, too.)
On loading of the list in waa__input_tree() two memory ranges are 
allocated - one for the "struct estat"s read, and one for the filenames.

Because of this free()ing of entries is currently not possible - a 
freelist should be implemented.


3) Algorithms and assumption in the code
Generally I tried to use fast and simple algorithms better than O(n).
Though it's entirely possible that I forgot something.


3a) Searching for an entry in a directory (in memory) 
is O(log2(n)), as I use bsearch().


3b) Determining the correct order for writing the entries 
(in waa__output_tree()) is optimized by having all lists sorted; 
about half the time a single compare is enough to determine the 
next written entry.


3c) by_inode and by_name
by_inode must always exists; by_name is optional.
Both *must* be sorted, if != NULL.
Both arrays *must* be a pointer longer than the number of child entries, and 
this must be a NULL-pointer (eg. for waa__output_tree());


3d) Manber-Hash and MD5
To quickly find whether a given file has changed, and to send only the 
changed bytes over the wire, we take a running hash (a Manber-Hash), and
whenever we find a "magic" value we take that as buffer end.

We calculate the MD5 of each buffer, and store them along with their 
start offset in the file.
So on commit we can find identical blocks and send only those, and while
comparing we can return "changed" as soon as we find a difference.


3e) Error checking and stopping
Return codes are checked everywhere.
The return value of functions in this program is normally (int);
0 means success, something else an error.
Either this error is expected (eg. ENOENT, file not found) and handled,
or it must be returned to the caller.
Most of this is already defined in macros.

Typical function layout is like this (taken from waa.c):
	int waa__make_info_link(char *directory, char *name, char *dest)
	{
	  int status;
	  char *path, *eos;
	
	
	  STOPIF( waa___get_waa_directory(directory, &path, &eos), NULL);
	
	  strcpy(eos, name);
	  /* If the link does not exist, try to make it. */
	  if (access(path, F_OK) != 0)
	    STOPIF_CODE_ERR( symlink(dest, path) == -1,
	        errno, "cannot create informational symlink '%s' -> '%s'",
	        path, dest);
	
	ex:
	  return status;
	}

When a function gets called by subversion libraries, we have to use
their return type.
Here an example in commit.c:
	svn_error_t * ac__commit_callback (
		svn_revnum_t new_revision,
		const char *date,
		const char *author,
		void *baton)
	{
	  struct estat *root=baton;
	  int status;
	
	
	  printf("committed revision\t%ld on %s as %s\n",
	      new_revision, date, author);
	
	  /* recursively set the new revision */
	  STOPIF( ac___ci_setrev(root, new_revision), NULL);
	ex:
	  RETURN_SVNERR(status);
	}

The various STOPIF-macros automatically print an error message and,
depending on the debug- and verbosity-flags given on the command line,
a back trace too.

Assertions should be checked by BUG_ON(condition, format_string, ...).
This will cause a segmentation violation, which in turn should automatically
attach a debugger (gdb, only if present on the system).



# vi: sw=8 ts=8
